## 解题思路

1. 思路关键点, 创建 [0-9] 空数组, 利用数字游戏的值作为数组下标, 将数字出现次数计为对应的值; 

例子: secret = "1123", guess = "0111"

第一次 for 遍历, 达到两个效果, 如果相等则计为 A++; 如果不相等, 则将对应的值次数加一, 记录在对应数组; 
1>. secret[1] == guess[1], A++;
2>. 不相同记录次数在数组: 
    secretArr = [0, 1, 1, 1, 0, 0, 0, 0, 0, 0]; guessArr = [1, 2, 0, 0, 0, 0, 0, 0, 0, 0];

第二次 for 遍历, 找到对应相同值出现的次数, 即 secretArr, guessArr 相同下标的最小值相加 min(secretArr[1], guessArr[1])

即得到 1A1B

tips: 
1>. in/int64 转字符串

s := strconv.Itoa(88) // s == "88"
s := strconv.FormatInt(97, 10) // s == "97" (十进制)

警告：在普通转换中，该值将解释为 Unicode 码位，并且生成的字符串将包含该码位表示的字符，并以 UTF-8 编码。

s := string(97) // s == "a"

2>. 字符串转 int/int64

n, err := strconv.Atoi("97")
n, err := strconv.ParseInt("97", 10, 64)

3>. int 和 int64 互转

int64(99)

一个 int 的大小是基于操作系统特定实现的，它可能是 32 位，也可能是 64 位，因此从 int 转换为 int64 时，您不会丢失任何信息。但是，当转换为较短的整数类型时，该值将被截断以适合结果类型的大小。








